/* 
	Copyright(C) 2018 The University of Texas at Dallas
	Developed By: Muhammet Emin Yanik
	Advisor: Prof. Murat Torlak
	Department of Electrical and Computer Engineering

	This work was supported by the Semiconductor Research Corporation (SRC) task 2712.029
	through The University of Texas at Dallas' Texas Analog Center of Excellence (TxACE).

	Redistributions and use of source must retain the above copyright notice
	Redistributions in binary form must reproduce the above copyright notice
*/

/*
	This code counts pulses generated by the Motion Controller
	and triggers Radar after a predefined number of pulses

	Functionality of GPIOs used in this example:
     GPIO4 - pulse input pin,
     GPIO5 - control input pin.
    
	To do this test, you should connect the pulse output of the Motion Controller to GPIO4.
	GPIO5 is the control signal, you can leave it floating with internal pull up,
	or connect it to ground. If left floating, the count value will be increasing.
	If you connect GPIO5 to GND, the count value will be decreasing.
  
	The radar is triggered when the counter value:
	reaches a threshold value,
 */

/*
  Module Name:

	main.c

  Abstract:

	The entry point of the application
*/


#include <RadarTrigger.h>


/* Configure LED PWM Controller
 * to output sample pulses at 1 Hz with duty of about 10%
 */
static void ledc_init(void)
{
    // Prepare and then apply the LEDC PWM timer configuration
    ledc_timer_config_t ledc_timer;
    ledc_timer.speed_mode       = LEDC_HIGH_SPEED_MODE;
    ledc_timer.timer_num        = LEDC_TIMER_1;
    ledc_timer.duty_resolution  = LEDC_TIMER_10_BIT;
    ledc_timer.freq_hz          = 1;  // set output frequency at 1 Hz
    ledc_timer_config(&ledc_timer);

    // Prepare and then apply the LEDC PWM channel configuration
    ledc_channel_config_t ledc_channel;
    ledc_channel.speed_mode = LEDC_HIGH_SPEED_MODE;
    ledc_channel.channel    = LEDC_CHANNEL_1;
    ledc_channel.timer_sel  = LEDC_TIMER_1;
    ledc_channel.intr_type  = LEDC_INTR_DISABLE;
    ledc_channel.gpio_num   = LEDC_OUTPUT_IO;
    ledc_channel.duty       = 100; // set duty at about 10%
    ledc_channel.hpoint     = 0;
    ledc_channel_config(&ledc_channel);
}

void app_main(void)
{
    /* Initialize LEDC to generate sample pulse signal */
    ledc_init();

    BaseType_t xReturned;
	TaskHandle_t xRadarTriggerTask = NULL;
	
    /* Create the task, storing the handle. */
    xReturned = xTaskCreate(vRadarTriggerTask,       /* Function that implements the task. */
                    		"RadarTriggerTask",     /* Text name for the task. */
                    		1024,                   /* Stack size in words, not bytes. */
                    		NULL,               	/* Parameter passed into the task. */
                    		0,                      /* Priority at which the task is created. */
                    		&xRadarTriggerTask );	/* Used to pass out the created task's handle. */

    if( xReturned != pdPASS )
    {
        /* The task is created. */
        
        /* Start the RTOS scheduler, this function should not return as it causes the
   		execution context to change from main() to one of the created tasks. */
   		vTaskStartScheduler();

		/* Should never get here! */
    }
	
}



void vRadarTriggerTask(void* pvParameters)
{
    /*
        The parameter value is expected to be NULL as passed in the
        pvParameters value in the call to xTaskCreate() below.
    */
    configASSERT(pvParameters == NULL);

    /* Initialize PCNT event queue and PCNT functions */
    pcntEvtQueue = xQueueCreate(10, sizeof(pcnt_evt_t));
    pcnt_example_init();

    int16_t count = 0;
    pcnt_evt_t evt;
    portBASE_TYPE res;

    while (1) {
        /* Wait for the event information passed from PCNT's interrupt handler.
         * Once received, decode the event type and print it on the serial monitor.
         */
        res = xQueueReceive(pcntEvtQueue, &evt, 1000 / portTICK_PERIOD_MS);
        if (res == pdTRUE) {
            pcnt_get_counter_value(PCNT_TEST_UNIT, &count);
            printf("Event PCNT unit[%d]; cnt: %d\n", evt.unit, count);
            if (evt.status & PCNT_STATUS_THRES1_M) {
                printf("THRES1 EVT\n");
            }
            if (evt.status & PCNT_STATUS_THRES0_M) {
                printf("THRES0 EVT\n");
            }
            if (evt.status & PCNT_STATUS_L_LIM_M) {
                printf("L_LIM EVT\n");
            }
            if (evt.status & PCNT_STATUS_H_LIM_M) {
                printf("H_LIM EVT\n");
            }
            if (evt.status & PCNT_STATUS_ZERO_M) {
                printf("ZERO EVT\n");
            }
        } else {
            pcnt_get_counter_value(PCNT_TEST_UNIT, &count);
            printf("Current counter value :%d\n", count);
        }
    }

    /* Should never get here! */
    
    // if(radarIsrHandle) {
    //     //Free the ISR service handle.
    //     esp_intr_free(radarIsrHandle);
    //     radarIsrHandle = NULL;
    // }
}